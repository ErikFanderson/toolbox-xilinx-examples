#===============================================================================
# Autogenerated UARTDriver from uart-interface-generator
# Author: erik
# Date Created: 04/27/2021-13:19:51
#===============================================================================

import serial

class UARTDriver:
    """Autogenerated UARTDriver from UART-interface-generator"""
    def __init__(self, **kwargs):
        self._ser = serial.Serial(**kwargs)
        self._fields = {'LED': {'registers': {'leds': {'write': True, 'width': 8, 'lsbit_total_bit_position': 0, 'lsbit_address': 0, 'lsbit_address_bit_position': 0, 'msbit_total_bit_position': 7, 'msbit_address': 0, 'msbit_address_bit_position': 7}}, 'start_address': 0, 'end_address': 0}, 'RESET': {'registers': {'reset': {'write': True, 'width': 1, 'lsbit_total_bit_position': 8, 'lsbit_address': 1, 'lsbit_address_bit_position': 0, 'msbit_total_bit_position': 8, 'msbit_address': 1, 'msbit_address_bit_position': 0}}, 'start_address': 1, 'end_address': 1}, 'I2C': {'registers': {'rv0_valid': {'write': True, 'width': 1, 'lsbit_total_bit_position': 16, 'lsbit_address': 2, 'lsbit_address_bit_position': 0, 'msbit_total_bit_position': 16, 'msbit_address': 2, 'msbit_address_bit_position': 0}, 'rv0_slave_address': {'write': True, 'width': 7, 'lsbit_total_bit_position': 17, 'lsbit_address': 2, 'lsbit_address_bit_position': 1, 'msbit_total_bit_position': 23, 'msbit_address': 2, 'msbit_address_bit_position': 7}, 'rv0_reg_address': {'write': True, 'width': 8, 'lsbit_total_bit_position': 24, 'lsbit_address': 3, 'lsbit_address_bit_position': 0, 'msbit_total_bit_position': 31, 'msbit_address': 3, 'msbit_address_bit_position': 7}, 'rv0_burst_count': {'write': True, 'width': 2, 'lsbit_total_bit_position': 32, 'lsbit_address': 4, 'lsbit_address_bit_position': 0, 'msbit_total_bit_position': 33, 'msbit_address': 4, 'msbit_address_bit_position': 1}, 'rv0_wdata0': {'write': True, 'width': 8, 'lsbit_total_bit_position': 34, 'lsbit_address': 4, 'lsbit_address_bit_position': 2, 'msbit_total_bit_position': 41, 'msbit_address': 5, 'msbit_address_bit_position': 1}, 'rv0_wdata1': {'write': True, 'width': 8, 'lsbit_total_bit_position': 42, 'lsbit_address': 5, 'lsbit_address_bit_position': 2, 'msbit_total_bit_position': 49, 'msbit_address': 6, 'msbit_address_bit_position': 1}, 'rv0_wdata2': {'write': True, 'width': 8, 'lsbit_total_bit_position': 50, 'lsbit_address': 6, 'lsbit_address_bit_position': 2, 'msbit_total_bit_position': 57, 'msbit_address': 7, 'msbit_address_bit_position': 1}, 'rv0_wdata3': {'write': True, 'width': 8, 'lsbit_total_bit_position': 58, 'lsbit_address': 7, 'lsbit_address_bit_position': 2, 'msbit_total_bit_position': 65, 'msbit_address': 8, 'msbit_address_bit_position': 1}, 'rv0_rd_wrn': {'write': True, 'width': 1, 'lsbit_total_bit_position': 66, 'lsbit_address': 8, 'lsbit_address_bit_position': 2, 'msbit_total_bit_position': 66, 'msbit_address': 8, 'msbit_address_bit_position': 2}, 'rv1_ready': {'write': True, 'width': 1, 'lsbit_total_bit_position': 67, 'lsbit_address': 8, 'lsbit_address_bit_position': 3, 'msbit_total_bit_position': 67, 'msbit_address': 8, 'msbit_address_bit_position': 3}, 'rv0_ready': {'write': False, 'width': 1, 'lsbit_total_bit_position': 68, 'lsbit_address': 8, 'lsbit_address_bit_position': 4, 'msbit_total_bit_position': 68, 'msbit_address': 8, 'msbit_address_bit_position': 4}, 'rv1_valid': {'write': False, 'width': 1, 'lsbit_total_bit_position': 69, 'lsbit_address': 8, 'lsbit_address_bit_position': 5, 'msbit_total_bit_position': 69, 'msbit_address': 8, 'msbit_address_bit_position': 5}, 'rv1_rdata0': {'write': False, 'width': 8, 'lsbit_total_bit_position': 70, 'lsbit_address': 8, 'lsbit_address_bit_position': 6, 'msbit_total_bit_position': 77, 'msbit_address': 9, 'msbit_address_bit_position': 5}, 'rv1_rdata1': {'write': False, 'width': 8, 'lsbit_total_bit_position': 78, 'lsbit_address': 9, 'lsbit_address_bit_position': 6, 'msbit_total_bit_position': 85, 'msbit_address': 10, 'msbit_address_bit_position': 5}, 'rv1_rdata2': {'write': False, 'width': 8, 'lsbit_total_bit_position': 86, 'lsbit_address': 10, 'lsbit_address_bit_position': 6, 'msbit_total_bit_position': 93, 'msbit_address': 11, 'msbit_address_bit_position': 5}, 'rv1_rdata3': {'write': False, 'width': 8, 'lsbit_total_bit_position': 94, 'lsbit_address': 11, 'lsbit_address_bit_position': 6, 'msbit_total_bit_position': 101, 'msbit_address': 12, 'msbit_address_bit_position': 5}}, 'start_address': 2, 'end_address': 12}} 

#-------------------------------------------------------------------------------
# Basic read/write methods
#-------------------------------------------------------------------------------
    
    def open(self):
        self._ser.open()

    def close(self):
        self._ser.reset_input_buffer()
        self._ser.reset_output_buffer()
        self._ser.close()
 
    def write_byte(self, address: int, data: int):
        num_bytes = self._ser.write(bytes([address, data]))
 
    def read_byte(self, address: int) -> int:
        self._ser.write((address + 128).to_bytes(1, "big"))
        return int.from_bytes(self._ser.read(), "big")

#-------------------------------------------------------------------------------
# Register methods 
#-------------------------------------------------------------------------------
    
    def resize(self, bin_string, new_width):
        if len(bin_string) > new_width: # Truncate
            return bin_string[len(bin_string) - new_width:len(bin_string)]
        elif len(bin_string) < new_width: # Extend
            return (new_width - len(bin_string))*"0" + bin_string
        else:
            return bin_string
    
    def read_all_bytes(self, field: str, reg: str) -> str:
        bin_strings = []
        start_address = self._fields[field]["registers"][reg]["lsbit_address"]
        end_address = self._fields[field]["registers"][reg]["msbit_address"]
        for i in range(start_address, end_address + 1):
            bin_strings.append(f'{self.read_byte(i):08b}')
        bin_string = ""
        for i, bs in enumerate(bin_strings):
            bin_string += bin_strings[len(bin_strings)-1-i]
        return bin_string
    
    def read_register(self, field: str, reg: str) -> str:
        bin_string = self.read_all_bytes(field, reg)
        lsb = len(bin_string) - self._fields[field]["registers"][reg]["lsbit_address_bit_position"]
        msb = 7 - self._fields[field]["registers"][reg]["msbit_address_bit_position"]
        return bin_string[msb:lsb]
    
    def write_register(self, field: str, reg: str, bin_string: str):
        # Read current value first
        current_value = self.read_all_bytes(field, reg)
        num_bits = len(current_value)
        # Resize binary value to write
        bin_string = self.resize(bin_string, self._fields[field]["registers"][reg]["width"])
        # Create new full value for all registers
        new_bin_string = list(current_value)
        for i, char in enumerate(bin_string):
            j = self._fields[field]["registers"][reg]["lsbit_address_bit_position"] 
            new_bin_string[(i + j + 1) * -1] = bin_string[(i + 1) * -1]
        new_bin_string = "".join(new_bin_string)
        # Write bytes
        start_address = self._fields[field]["registers"][reg]["lsbit_address"]
        end_address = self._fields[field]["registers"][reg]["msbit_address"]
        for addr in range(start_address, end_address + 1):
            i = addr - self._fields[field]["registers"][reg]["lsbit_address"]
            lsb = (num_bits - 1) - i * 8 + 1
            msb = (num_bits - 1) - ((i + 1) * 8) + 1
            data = new_bin_string[msb:lsb]
            self.write_byte(addr, int(data, 2))